setopt prompt_subst;

# --- Zsh Plugin Configuration ---
# Load zsh-syntax-highlighting (provides syntax highlighting as you type)
[ -f "/opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" ] && source "/opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
# For Intel Macs, it might be:
# [ -f "/usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" ] && source "/usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"

# Load zsh-autosuggestions (provides faded-out command suggestions)
[ -f "/opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh" ] && source "/opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
# For Intel Macs, it might be:
# [ -f "/usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh" ] && source "/usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh"

# fzf keybindings and fuzzy completion (crucial for Ctrl+R history search)
# This line is usually generated by `~/.fzf/install` or `brew install fzf`
[ -f "$(brew --prefix)/opt/fzf/shell/key-bindings.zsh" ] && source "$(brew --prefix)/opt/fzf/shell/key-bindings.zsh"
# --- End Zsh Plugin Configuration ---

# path fixes
export PATH=$PATH:$(go env GOPATH)/bin

# adding aliases to the PATH
source "$HOME/.aliases";

# --- Git Functions for Prompt ---
git_branch() {
    local branchName=''

    # Check for what branch we’re on.
    # Get the short symbolic ref. If HEAD isn’t a symbolic ref, get a
    # tracking remote branch or tag. Otherwise, get the
    # short SHA for the latest commit, or give up.
    branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
        git describe --all --exact-match HEAD 2> /dev/null || \
        git rev-parse --short HEAD 2> /dev/null || \
        echo '(unknown)')";
    
    echo -e "${branchName}";
}

git_status() {
    local s=''

    # Early exit for Chromium & Blink repo, as the dirty check takes too long.
    # Thanks, @paulirish!
    # https://github.com/paulirish/dotfiles/blob/dd33151f/.bash_prompt#L110-L123
    repoUrl="$(git config --get remote.origin.url)";
    if grep -q 'chromium/src.git' <<< "${repoUrl}"; then
        s+='*';
    else
        # Check for uncommitted changes in the index.
        if ! $(git diff --quiet --ignore-submodules --cached); then
            s+='+';
        fi;
        # Check for unstaged changes.
        if ! $(git diff-files --quiet --ignore-submodules --); then
            s+='!';
        fi;
        # Check for untracked files.
        if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            s+='?';
        fi;
        # Check for stashed files.
        if $(git rev-parse --verify refs/stash &>/dev/null); then
            s+='$';
        fi;
    fi;

    [ -n "${s}" ] && s=" [${s}]";

    echo -e "${s}";
}
# --- End Git Functions for Prompt ---


# --- Prompt Configuration ---
prompt_header() {
    local header='%B';

    header+='%F{166}%n%f'; # username
    header+=' at ';
    header+='%F{136}%m%f'; # host
    header+=' in ';
    header+='%F{64}%~%f'; # working directory
    if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        # add git info if the current directory is in a repo
        header+=' on ';
        header+='%F{61}$(git_branch)%f'; # git branch
        header+='%F{33}$(git_status)%f'; # git status
    fi
    header+='%b';

    echo -e "${header}";
}

# prompt
precmd() {
    echo # add newline before prompt header
    print -rP "$(prompt_header)"
}
PROMPT="%B%F{15}$%f%b ";
PS2="%B%F{136}→%f%b ";
# --- End Prompt Configuration ---


# --- Custom Utility Functions ---
togglenetskope() {
    # check if Netskope directory exists in /Library/Application Support and if does, move it to /Library/Application Support/Netskope_disabled
    if [ -d "/Library/Application Support/Netskope" ]
    then
        sudo mv /Library/Application\ Support/Netskope /Library/Application\ Support/Netskope_disabled
        echo "Netskope will shortly be disabled!"
    else
        sudo mv /Library/Application\ Support/Netskope_disabled /Library/Application\ Support/Netskope
        echo "Netskope will shortly be enabled!"
    fi

    pids=$(ps aux | grep Netskope | grep -v grep | awk '{print $2}')

    # go through each pid and kill it
    while IFS= read -r pid; do
        sudo kill -9 "$pid"
        echo $?
    done <<< "$pids"
}

function y() {
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
    yazi "$@" --cwd-file="$tmp"
    if [ -f "$tmp" ]; then
        cwd=$(cat "$tmp")
    fi
    [ -n "$cwd" ] && [ "$cwd" != "$PWD" ] && builtin cd -- "$cwd"
    rm -f -- "$tmp"
}

# GIT_ROOT is a global variable, so 'local' is not used here.
GIT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"

# A powerful, context-aware project finder that displays clean, relative paths.
# If run inside a git repository, it searches only within that project.
# Otherwise, it searches from your home directory.
# Usage: Type 'ff' in your terminal and press Enter.
ff() {
    # Attempt to find the root of the current git repository. 
    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    
    local search_path
    # Check if we are inside a git repository.
    if [[ -n "$git_root" ]]; then
        # If yes, set the search path to the project's root directory.
        search_path="$git_root"
    else
        # If no, fall back to searching from the home directory.
        search_path="$HOME"
    fi

    # We need to export the search_path so the fzf preview subshell can access it.
    export FZF_FF_SEARCH_PATH="$search_path"

    # Find directories, strip the base path for a clean display, and pipe to fzf.
    local selected_relative_path
    selected_relative_path=$(fd --type d . "$search_path" --hidden --exclude .git --exclude node_modules \
        | sed "s|^$search_path/||" \
        | fzf \
            --preview "eza --tree --color=always --icons=always --level=2 \"$FZF_FF_SEARCH_PATH\"/{}" \
            --preview-window 'right:50%' \
            --height '80%' \
            --border 'rounded' \
            --header 'Project Finder | Press Enter to select')

    # If a directory was selected (i.e., you pressed Enter)...
    if [[ -n "$selected_relative_path" ]]; then
        # ...reconstruct the full path by prepending the search_path.
        local full_path="$search_path/$selected_relative_path"
        # Change the current directory of your terminal to that full path.
        cd "$full_path" || return
        # Optional: clear the screen and show a tree of the new location.
        clear
        eza --tree --icons=always --level=2 # Corrected eza flag
    fi
}

ffn() {
    # Attempt to find the root of the current git repository. 
    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    
    local search_path
    # Check if we are inside a git repository.
    if [[ -n "$git_root" ]]; then
        # If yes, set the search path to the project's root directory.
        search_path="$git_root"
    else
        # If no, fall back to searching from the home directory.
        search_path="$HOME"
    fi

    # We need to export the search_path so the fzf preview subshell can access it.
    export FZF_FF_SEARCH_PATH="$search_path"

    # Find directories, strip the base path for a clean display, and pipe to fzf.
    local selected_relative_path
    selected_relative_path=$(fd --type d . "$search_path" --hidden --exclude .git --exclude node_modules \
        | sed "s|^$search_path/||" \
        | fzf \
            --preview "eza --tree --color=always --icons=always --level=2 \"$FZF_FF_SEARCH_PATH\"/{}" \
            --preview-window 'right:50%' \
            --height '80%' \
            --border 'rounded' \
            --header 'Project Finder | Press Enter to select')

    # If a directory was selected (i.e., you pressed Enter)...
    if [[ -n "$selected_relative_path" ]]; then
        # ...reconstruct the full path by prepending the search_path.
        local full_path="$search_path/$selected_relative_path"
        cd "$full_path"
        # Get the name of the current directory to use as the session name.
        # We replace periods with underscores as they can be problematic in session names.
        local session_name=$(basename "$PWD" | tr '.' '_')
        # Launch Zellij, creating a new session named after the directory,
        # and have it immediately start nvim in the current path.
        # zellij --session "$session_name" -- nvim .
        nvim .
    fi
}

# Function: fch (Fuzzy Command History)
# Description:
#   Launches an interactive fzf session to search through your entire Zsh history.
#   Allows fuzzy matching, navigation with arrow keys, and immediate execution
#   of the selected command upon pressing Enter.
#   The display and matching behavior will be similar to your 'ff' command.
#
# Usage:
#   Type 'fch' in your terminal and press Enter.
#   Inside the fzf window:
#     - Type any part of a command to fuzzy-filter the history.
#     - Use Up/Down arrow keys to navigate the filtered list.
#     - Press Enter to execute the highlighted command.
#     - Press Ctrl+Y to paste the command to the prompt for editing.
#     - Press Esc or Ctrl+C to cancel and return to the prompt.
fch() {
    local selected_command

    # Get the entire history list (fc -l 1) and remove the leading history number
    # (e.g., "   123  ls -la" becomes "ls -la") for cleaner fzf display.
    selected_command=$( \
        fc -l 1 | \
        sed 's/^[[:space:]]*[0-9]*[[:space:]]*//' | \
        fzf \
            --no-sort \
            --height '80%' \
            --border 'rounded' \
            --header 'Fuzzy History Search | Enter to execute, Ctrl+Y to paste' \
            --ansi # Enable ANSI color codes in fzf if your history has them
    )

    # If a command was selected (user pressed Enter in fzf)
    if [[ -n "$selected_command" ]]; then
        # Print the command to the terminal before executing it, for clarity.
        # This makes it clear what command is about to run.
        echo "$selected_command"
        # Execute the selected command.
        # 'eval' is necessary to run the string as a shell command.
        eval "$selected_command"
    fi
}

add_req() {
    if [[ $# -lt 3 ]]; then
        echo "Usage: add_req <collection_name> <request_name> \"<curl_command>\""
        echo "Example: add_req my_api \"get_users\" \"curl -X GET https://api.example.com/users -H 'Authorization: Bearer token'\""
        return 1
    fi

    local collection_name="$1"
    local request_name="$2"
    local curl_command="$3"

    # Check if collection exists
    local collections=$(atac collection list 2>/dev/null)
    if ! echo "$collections" | grep -q "^$collection_name$"; then
        echo "Error: Collection '$collection_name' does not exist."
        echo "Available collections:"
        atac collection list 2>/dev/null || echo "  (no collections found)"
        echo "Create a collection first with: atac collection new <collection_name>"
        return 1
    fi

    # Create a temporary file for the curl command
    local temp_file=$(mktemp /tmp/curl_cmd.XXXXXX)
    echo "$curl_command" > "$temp_file"

    # Import the curl command using atac's built-in import functionality
    if atac import curl "$temp_file" "$collection_name" "$request_name"; then
        echo "✅ Successfully added request '$request_name' to collection '$collection_name'"
    else
        echo "❌ Failed to add request '$request_name' to collection '$collection_name'"
        rm -f "$temp_file"
        return 1
    fi

    # Clean up temporary file
    rm -f "$temp_file"
}

# Curl wrapper that automatically pipes JSON/NDJSON output to jqp
curl() {
    # Check if jqp is available
    if ! command -v jqp >/dev/null 2>&1; then
        # If jqp is not available, just run regular curl
        command curl "$@"
        return $?
    fi

    # Create temporary files for output and headers
    local temp_output=$(mktemp /tmp/curl_output.XXXXXX)
    local temp_headers=$(mktemp /tmp/curl_headers.XXXXXX)
    
    # Run curl and capture output and headers
    local curl_exit_code
    command curl -D "$temp_headers" -o "$temp_output" "$@"
    curl_exit_code=$?
    
    # If curl failed, show the output and return
    if [[ $curl_exit_code -ne 0 ]]; then
        cat "$temp_output"
        rm -f "$temp_output" "$temp_headers"
        return $curl_exit_code
    fi
    
    # If output is empty, just show headers if any
    if [[ ! -s "$temp_output" ]]; then
        cat "$temp_headers"
        rm -f "$temp_output" "$temp_headers"
        return $curl_exit_code
    fi
    
    # Check Content-Type header for JSON
    local content_type=$(grep -i "^content-type:" "$temp_headers" | tail -1 | cut -d: -f2- | tr -d ' \r\n' | tr '[:upper:]' '[:lower:]')
    local is_json_content_type=false
    
    if [[ "$content_type" == *"application/json"* ]] || [[ "$content_type" == *"application/ndjson"* ]] || [[ "$content_type" == *"text/json"* ]]; then
        is_json_content_type=true
    fi
    
    # Try to detect JSON by content (check first few characters)
    local first_chars=$(head -c 10 "$temp_output" | tr -d '[:space:]')
    local looks_like_json=false
    
    # Check if it starts with JSON-like characters or is NDJSON
    if [[ "$first_chars" =~ ^[\{\[ ]] || [[ -n "$(head -1 "$temp_output" | jq . 2>/dev/null)" ]]; then
        looks_like_json=true
    fi
    
    # Check if the entire content is valid JSON
    local is_valid_json=false
    if jq . "$temp_output" >/dev/null 2>&1; then
        is_valid_json=true
    fi
    
    # Check if it's NDJSON (newline-delimited JSON)
    local is_ndjson=false
    if [[ "$is_valid_json" == false ]] && [[ "$looks_like_json" == true ]]; then
        # Try to validate as NDJSON (each line should be valid JSON)
        local ndjson_valid=true
        while IFS= read -r line; do
            if [[ -n "$line" ]] && ! echo "$line" | jq . >/dev/null 2>&1; then
                ndjson_valid=false
                break
            fi
        done < "$temp_output"
        if [[ "$ndjson_valid" == true ]]; then
            is_ndjson=true
        fi
    fi
    
    # Show headers if requested (when -I, -head, or -D options are used)
    local show_headers=false
    for arg in "$@"; do
        if [[ "$arg" == "-I" ]] || [[ "$arg" == "--head" ]] || [[ "$arg" == "-D" ]] || [[ "$arg" == "--dump-header" ]]; then
            show_headers=true
            break
        fi
    done
    
    if [[ "$show_headers" == true ]]; then
        cat "$temp_headers"
    fi
    
    # If it's JSON or NDJSON, pipe to jqp; otherwise show normally
    if [[ "$is_valid_json" == true ]] || [[ "$is_ndjson" == true ]] || [[ "$is_json_content_type" == true && "$looks_like_json" == true ]]; then
        echo "🔍 JSON detected - opening in jqp (press 'q' to quit)"
        sleep 1
        cat "$temp_output" | jqp
    else
        cat "$temp_output"
    fi
    
    # Clean up temporary files
    rm -f "$temp_output" "$temp_headers"
    return $curl_exit_code
}

# A function to read XML files with formatting and syntax highlighting
r_xml() {
  # Check if a filename was provided
  if [ -z "$1" ]; then
    echo "Usage: r_xml <filename.xml>"
    return 1
  fi

  # Format the file with xmlstarlet and pipe to bat
  xmlstarlet format "$1" | bat -l xml --paging=always
}

# Kill process using a specific port
k_port() {
    if [ -z "$1" ]; then
        echo "Usage: k_port <port>"
        echo "Example: k_port 8080"
        return 1
    fi
    
    local port="$1"
    
    # Find PIDs using the port
    local pids=$(lsof -ti :$port 2>/dev/null)
    
    if [ -z "$pids" ]; then
        echo "No process found using port $port"
        return 0
    fi
    
    # Show what processes will be killed
    echo "Found processes using port $port:"
    lsof -i :$port
    echo ""
    
    # Kill each PID
    echo "$pids" | while read -r pid; do
        if kill -9 "$pid" 2>/dev/null; then
            echo "✅ Killed process $pid"
        else
            echo "❌ Failed to kill process $pid (might need sudo)"
        fi
    done
    
    # Verify port is free
    sleep 1
    if lsof -ti :$port >/dev/null 2>&1; then
        echo ""
        echo "⚠️  Some processes still using port $port. Try running with sudo:"
        echo "sudo k_port $port"
    else
        echo ""
        echo "✅ Port $port is now free"
    fi
}


# ghc (Git Clone) - Interactively find and clone a repository from a GitHub
# organization into a structured directory (~/GitHub/<org>/<repo>).
ghc() {
  # --- 1. Validate Input ---
  if [ -z "$1" ]; then
    echo "Usage: gc <organization_name>"
    echo "Example: gc google"
    return 1
  fi

  # --- 2. Define Variables ---
  local org="$1"
  local base_dir="$HOME/GitHub"
  local org_dir="$base_dir/$org"
  local repo_list
  local selected_repo
  local repo_name
  local repo_basename

  # --- 3. Get Repository List ---
  # Use gh to list repos. If it fails, exit.
  # The '|| return 1' part stops the script if gh repo list fails.
  echo "Fetching repositories for '$org'..."
  repo_list=$(gh repo list "$org" --limit 1000) || return 1

  # Check if any repositories were found
  if [ -z "$repo_list" ]; then
      echo "No repositories found for organization '$org' or organization does not exist."
      return 1
  fi

  # --- 4. Interactive Selection with fzf ---
  selected_repo=$(echo "$repo_list" | fzf --prompt="Select a repo from '$org' > " --height="40%" --border)

  # --- 5. Clone the Repository ---
  # Proceed only if a repository was selected (fzf wasn't cancelled with Esc)
  if [ -n "$selected_repo" ]; then
    # Extract just the full repo name (e.g., "google/go-cloud")
    repo_name=$(echo "$selected_repo" | awk '{print $1}')
    # Extract just the repository's base name (e.g., "go-cloud")
    repo_basename=$(basename "$repo_name")

    # Create the base GitHub and organization directories if they don't exist
    mkdir -p "$org_dir"

    # Define the final destination path
    local final_dest="$org_dir/$repo_basename"

    echo "\nCloning $repo_name into $final_dest..."
    gh repo clone "$repo_name" "$final_dest"
  else
    echo "No repository selected."
  fi
}

# ffgn (Fuzzy Find Git Nav) - Interactively find a repository within ~/GitHub and open it in Neovim.
ffgn() {
    # The search path is always the ~/GitHub directory.
    local search_path="$HOME/GitHub"

    # Check if the GitHub directory exists.
    if [[ ! -d "$search_path" ]]; then
        echo "Directory not found: $search_path"
        echo "Please clone a repository with 'gc <org>' first."
        return 1
    fi

    # We need to export the search_path so the fzf preview subshell can access it.
    export FZF_FFGN_SEARCH_PATH="$search_path"

    # Find directories within ~/GitHub, limiting the depth to 2 levels (org/repo),
    # strip the base path for a clean display, and pipe to fzf.
    local selected_relative_path
    selected_relative_path=$(fd --type d --max-depth 2 . "$search_path" --hidden --exclude .git --exclude node_modules \
        | sed "s|^$search_path/||" \
        | fzf \
            --preview "eza --tree --color=always --icons=always --level=2 \"$FZF_FFGN_SEARCH_PATH\"/{}" \
            --preview-window 'right:50%' \
            --height '80%' \
            --border 'rounded' \
            --header 'GitHub Project Finder | Press Enter to open in Neovim')

    # If a directory was selected (i.e., you pressed Enter)...
    if [[ -n "$selected_relative_path" ]]; then
        # ...reconstruct the full path by prepending the search_path.
        local full_path="$search_path/$selected_relative_path"
        # Open the selected directory in Neovim.
        cd "$full_path"
        # Set the Warp terminal tab name to the repository name
        wtn
        nvim .
    fi
}

# --- Warp Terminal Tab Functions ---
# wtn (Warp Tab Name) - Set terminal tab name with a random color ball emoji
# Usage: wtn "Custom Name" or just wtn (uses current directory/repo name)
function wtn () {
  local tab_name="${1:-$(basename "$PWD")}"
  
  # Array of color ball emojis
  local color_balls=("🔴" "🟠" "🟡" "🟢" "🔵" "🟣" "🟤" "⚫" "⚪" "🟦" "🟧" "🟨" "🟩" "🟪" "🟫")
  
  # Get a random color ball
  local random_index=$((RANDOM % ${#color_balls[@]}))
  local color_ball="${color_balls[$random_index]}"
  
  # Set the tab title with the color ball
  echo -ne "\033]0;${color_ball} ${tab_name}\007"
}

# watn (Warp Auto Tab Name) - Automatically set tab name on every prompt
# This runs automatically to keep the tab name updated with the current directory
function watn () {
  wtn
}

# Add the auto function to precmd_functions for automatic updates
if [[ ! " ${precmd_functions[@]} " =~ " watn " ]]; then
  precmd_functions+=(watn)
fi
# --- End Warp Terminal Tab Functions ---

# fpr (Fuzzy Pull Request) - Interactively find and open one of your open GitHub PRs.
fpr() {
    # Fetch the list of open PRs assigned to you using the gh CLI.
    # The format argument creates a clean, tab-separated string with relevant info.
    local pr_list
    pr_list=$(gh search prs --author "@me" --state open --json repository,number,title,url --template '{{range .items}}{{.repository.nameWithOwner}}\t#{{.number}}\t{{.title}}\t{{.url}}{{"\n"}}{{end}}')

    # Check if the command was successful and if any PRs were returned.
    if [ -z "$pr_list" ]; then
        echo "No open pull requests found for you.";
        return 1;
    fi

    # Pipe the list of PRs into fzf for interactive selection.
    # --ansi is used to correctly render any potential colors.
    # --nth=1,2,3 tells fzf to search within the repo name, PR number, and title.
    # The selected line is stored in the 'selected_pr' variable.
    local selected_pr
    selected_pr=$(echo -e "$pr_list" | fzf \
        --prompt="Select a Pull Request to open > " \
        --height="40%" \
        --border \
        --ansi \
        --nth=1,2,3 \
        --preview 'echo -e "$(echo {} | cut -f 1-3)" | cut -c -$(tput cols)' \
        --preview-window 'top:1:wrap')

    # If a PR was selected (fzf wasn't cancelled), open its URL in the browser.
    if [ -n "$selected_pr" ]; then
        # Extract the URL (the 4th tab-separated field).
        local pr_url
        pr_url=$(echo "$selected_pr" | awk -F'\t' '{print $4}')
        # Open the URL in the default web browser.
        open "$pr_url";
    else
        echo "No pull request selected."
    fi
}